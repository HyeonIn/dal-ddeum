```java
@Entity
@Getter @Setter
public class Member {
    @Id @GeneratedValue
    @Column(name = "member_id")
    private Long id;

    private String name;

    @Embedded
    private Address address;

    @OneToMany(mappedBy = "member")
    private List<Order> orders = new ArrayList<>();

}
```

예제에서는 Getter, Setter를 모두 열고, 최대한 단순하게 설계

실무에서는 가급적 Getter는 열어두고, **Setter는 꼭 필요한 경우**에만 사용!

왜??

JPA에서는 Setter 메소드를 실행하는 순간 DB에 Update 쿼리가 나가는 데이터 변경이 이루어진다.

도대체 왜 변경되는지 추적하기 어려워진다.

따라서

Setter 대신에 변경 지점이 명확하도록 변경을 위한 비즈니스 메서드를 별도로 제공해야 한다.

중요한 것은 일관성!

Entity의 식별자는 id를 사용하고 PK 컬럼명은 member_id를 사용했다.

테이블은 타입이 없으므로 구분이 어렵다. 관례상 테이블명 _ id를 많이 사용한다.

```java
@Embeddable
@Getter
public class Address {
    private String city;
    private String street;
    private String zipcode;

    // JPA 스펙상 만들어 놓음.
    protected Address() {
    }

    public Address(String city, String street, String zipcode) {
        this.city = city;
        this.street = street;
        this.zipcode = zipcode;
    }
}
```

참고 : 값 타입은 변경 불가능하게 설계해야 한다.

@Setter 를 제거하고 생성자에서 값을 모두 초기화해서 변경 불가능한 클래스를 만들자

기본 생성자는 JPA 스펙상 만들어 놓는다.

모든 연관관계는 지연로딩으로 설정

즉시로딩(EAGER)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다.

특히 JPQL을 실행할 때 N+1 문제가 자주 발생한다.

@XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 한다.

컬렉션은 필드에서 초기화 하자

컬렉션은 필드에서 바로 초기화 하는 것이 안전하다.

null 문제에서 안전하다.

```java
private List<Order> orders = new ArrayList<>();

// 하이버네이트가 추적할 수 있는 객체로 변경시키기 때문에 필드 초기화 후 밖에서 건들 ㄴㄴ
```

Cascade

```java
@OneToOne(fetch= LAZY, cascade = CascadeType.ALL)
private Delivery delivery;
```

Cascade 하게 되면

persist 두번 해야 하는 것을 한번만 해주면 된다.

persist(delivery) → persist(order) 를 persist(order)만.