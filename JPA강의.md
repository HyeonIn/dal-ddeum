# JPA 강의

- JPA는 지연로딩과 즉시로딩을 모두 지원한다. → 성능최적화 가능
    - 지연로딩: 객체가 실제 사용될 때 로딩
    - 즉시 로딩: JOIJ SQL로 한번에 연관된 객체까지 미리 조회

데이터베이스 방언: 각각의 디비가 제공하는 문법과 함수는 조금씩 다름. 

JPA는 트랜잭션에서 작업해야한다.

 

- 주의
    - 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유한다.
    - 엔티티 매니저는 스레드간에 공유불가(사용하고 버려야한다.)
    - JPA의 모든 데이터 변경은 트랜잭션 안에서 실행
- JPQL
    - 테이블이 엄청많아. 필요하면 조인도 해야해. 필요한 데이터를 최적으로 찾고싶어 → JPQL
    - 테이블 대상이 아닌 멤버객체를 대상으로 쿼리를 짠다.
    - 페이지네이션에 좋다: 방언이 다 적용되니까.
    - JPA를 사용하면 엔티티 객체를 중심으로 개발
    - 문제는 검색쿼리
    - 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
    - 모든 DB데이터를 객체로 변환해서 검색하는건 불가능하다.
    - 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조선이 포함된 SQL이 필요하다.
    - JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
    - SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원
    - 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리
    - JPQL은 엔티티 객체를 대상으로 쿼리 ↔ SQL은 데이터베이스 테이블을 대상으로 쿼리

---

## 영속성 컨텍스트(EntityManager)

- “엔티티를 영구 저장하는 환경”이라는 뜻
- EntitiyManager. persist(entitiy);
- 영속성 컨텍스트는 논리적인 개념. 엔티티매니저를 통해 영속성 컨텍스트에 접근한다.
- 영속성 컨텍스트된 상태에서 커밋해야 쿼리가 날아감
- 엔티티의 생명주기
    - 비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
    - 영속(managed): 영속성 컨텍스트에 관리되는 상태
    - 준영속( detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
    - 삭제(remove)
- 영속성 컨텍스트의 이점
    - 1차 캐시: `@ID` `@Entity` DB PK로 매핑한 것이 키가되고, 엔티티 객체 자체가 값이된다. 조회할때 쿼리를 보내는것이 아니라 1차캐시를 뒤져서 가져온다.
    - 동일성(identity) 보장: 1차 캐시로 반복가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공
    - 트랜잭션을 지원하는 쓰기 지연 : insert 를 DB에 보내지 않다가 커밋하는 순간 쿼리 보낸다. 쿼리를 쓸때마다     날리면 최적화 여지가 없어서.  batchsize : 모았다가 한번에 보내기 가능.
    - 변경 감지(Dirty Checking): flush() → 엔티티와 스냅샷(값을 읽어온 최초시점) 비교 → 업데이트 쿼리를 쓰기지연에 저장 → 쓰기지연의 쿼리를 데이터베이스에 전송→ flush()
    - 지연 로딩(Lazy Loading)
- 플러시 : 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
    - em.flush(): 직접 호출
    - 트랜잭션 호출, JPQL쿼리 실행 : 플러시 자동 호출
        - 자동호출되는 이유: 중간에 insert없이 조회하는 쿼리를 날리면 조회가 제대로 안됨. 그래서 JPQL을 실행할때는 무조건 플러시
    - 플러시 모드 옵션
        - FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시(기본값)
        - FlushModeType.COMMIT: 커밋할 때만 플러시
    - 영속성 컨텍스트를 비우지 않는다. 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화. 트랜잭션이라는 작업단위가 중요하다 → 커밋 직전에만 동기화하면됨!
- 준영속상태
    - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리( detached)
    - 영속성 컨텍스트가 제공하는 기능을 사용하지 못함
    - em.detach(entity): 특정 엔티티만 준영속상태로 전환
    - em.clear(): 영속성 컨텍스트를 완전히 초기화
    - em.close(): 영속성 컨텍스트를 종료